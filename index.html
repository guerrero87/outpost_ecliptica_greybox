<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Outpost Ecliptica - Greybox Prototype</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html,
    body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      color: #fff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    canvas {
      display: block;
    }

    #hud {
      position: fixed;
      inset: 0 auto auto 0;
      width: 100%;
      pointer-events: none;
      text-shadow: 0 0 4px #000;
      z-index: 5;
    }

    #hud-top {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-top: 10px;
    }

    #cycleStatus {
      font-size: 18px;
      font-weight: 700;
      margin-bottom: 4px;
    }

    #timerDisplay {
      font-size: 14px;
      opacity: 0.85;
    }

    #hud-bottom {
      position: fixed;
      bottom: 12px;
      left: 12px;
      font-size: 14px;
      pointer-events: none;
      z-index: 5;
    }

    #energyDisplay {
      margin-bottom: 4px;
    }

    #healthDisplay {
      font-size: 13px;
      opacity: 0.9;
    }

    #healthDisplay span + span {
      margin-left: 12px;
    }

    #crosshair {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 20px;
      height: 20px;
      pointer-events: none;
      z-index: 6;
    }

    #crosshair::before,
    #crosshair::after {
      content: "";
      position: absolute;
      background: rgba(255, 255, 255, 0.9);
    }

    #crosshair::before {
      left: 50%;
      top: 0;
      width: 2px;
      height: 100%;
      transform: translateX(-50%);
    }

    #crosshair::after {
      top: 50%;
      left: 0;
      width: 100%;
      height: 2px;
      transform: translateY(-50%);
    }

    #startOverlay,
    #gameOverOverlay,
    #pauseOverlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.75);
      color: #fff;
      z-index: 10;
      text-align: center;
    }

    #startOverlay.hidden,
    #gameOverOverlay.hidden,
    #pauseOverlay.hidden {
      display: none;
    }

    #startOverlay .panel,
    #gameOverOverlay .panel,
    #pauseOverlay .panel {
      max-width: 420px;
      padding: 24px 28px;
      background: rgba(10, 10, 10, 0.9);
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
    }

    h1 {
      font-size: 22px;
      margin-bottom: 8px;
    }

    p {
      font-size: 14px;
      margin-bottom: 4px;
    }

    #hint {
      font-size: 12px;
      opacity: 0.8;
      margin-top: 6px;
    }

    button {
      padding: 10px 18px;
      margin-top: 12px;
      border: none;
      background: #1e90ff;
      color: #fff;
      font-size: 14px;
      font-weight: 600;
      border-radius: 4px;
      cursor: pointer;
    }

    button:hover {
      background: #63b3ff;
    }

    .safe {
      color: #7cfc00;
    }

    .danger {
      color: #ff4d4f;
    }
  </style>
</head>
<body>
  <!-- Milestone #1: Environment & Setup - Static scene and basic lighting -->
  <div id="startOverlay">
    <div class="panel">
      <h1>Outpost Ecliptica - Greybox</h1>
      <p>Maintain the base during power cycles. When the system enters DANGER mode, the door and generator will decay.</p>
      <p>Look at the Door or Generator and hold Left Mouse Button to repair them using your energy.</p>
      <p id="hint">Controls: WASD to move · Mouse to look · Click to lock pointer.</p>
      <button id="startButton">Click to Start</button>
    </div>
  </div>
  <div id="pauseOverlay" class="hidden">
    <div class="panel">
      <h1>Paused</h1>
      <p>Simulation paused. Click Resume to continue.</p>
      <button id="resumeButton">Resume</button>
    </div>
  </div>

  <!-- Game Over Overlay -->
  <div id="gameOverOverlay" class="hidden">
    <div class="panel">
      <h1>Base Breached</h1>
      <p id="gameOverMessage">The door has failed. The outpost has been overrun.</p>
      <button id="restartButton">Restart Simulation</button>
    </div>
  </div>

  <!-- Milestone #3: Core Logic & UI - HUD elements -->
  <div id="hud">
    <div id="hud-top">
      <div id="cycleStatus" class="safe">SAFE CYCLE - SYSTEMS STABLE</div>
      <div id="timerDisplay">10.0s</div>
    </div>
    <div id="hud-bottom">
      <div id="energyDisplay">Energy: 100 / 100</div>
      <div id="healthDisplay">
        <span id="doorHealthDisplay">Door: 100%</span>
        <span id="lightHealthDisplay">Generator: 100%</span>
      </div>
    </div>
  </div>

  <!-- Milestone #2: Player Controller - Reticle -->
  <div id="crosshair"></div>

  <!-- Three.js + PointerLockControls via CDN (ES Modules) -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
    import { PointerLockControls } from 'https://unpkg.com/three@0.152.2/examples/jsm/controls/PointerLockControls.js?module';
    // Milestone #1: Environment & Setup --------------------------------------------------
    let scene;
    let camera;
    let renderer;
    let ambientLight;
    let pointLight;
    let roomMesh;
    let doorMesh;
    let generatorMesh;
    const wallMeshes = [];

    const ROOM_SIZE = 10;
    const ROOM_HALF_SIZE = ROOM_SIZE / 2;
    const ROOM_HEIGHT = 6;
    const PLAYER_HEIGHT = 1.6;
    const PLAYER_RADIUS = 0.6;
    const GENERATOR_COLLISION_RADIUS = 1.2;
    const CORRIDOR_WIDTH = 4;
    const WALL_THICKNESS = 0.4;

    // Milestone #2: Player Controller ----------------------------------------------------
    let controls;
    const keyStates = {};

    // Milestone #3: Core Logic & UI ------------------------------------------------------
    let cycleState = 'SAFE';
    const SAFE_DURATION = 10; // seconds
    const DANGER_DURATION = 20; // seconds
    let timer = SAFE_DURATION;

    let energy = 100;
    const MAX_ENERGY = 100;

    let doorHealth = 100;
    let lightHealth = 100;
    const MAX_HEALTH = 100;

    let isRepairing = false;
    let gameOver = false;
    let gameStarted = false;
    let isPaused = true;

    const DOOR_DECAY_PER_SEC = 5;
    const LIGHT_DECAY_PER_SEC = 5;
    const ENERGY_REGEN_SAFE = 50;
    const ENERGY_COST_PER_SEC = 10;
    const REPAIR_PER_SEC = 20;
    const INTERACT_DISTANCE = 4;

    const clock = new THREE.Clock();

    // Raycasting for interaction
    const raycaster = new THREE.Raycaster();
    const interactableMeshes = [];

    // Colors for visual feedback
    const doorHealthyColor = new THREE.Color(0x00ff00);
    const doorDamagedColor = new THREE.Color(0xff0000);

    // UI elements
    const startOverlay = document.getElementById('startOverlay');
    const startButton = document.getElementById('startButton');
    const pauseOverlay = document.getElementById('pauseOverlay');
    const resumeButton = document.getElementById('resumeButton');
    const gameOverOverlay = document.getElementById('gameOverOverlay');
    const gameOverMessage = document.getElementById('gameOverMessage');
    const restartButton = document.getElementById('restartButton');

    const cycleStatusEl = document.getElementById('cycleStatus');
    const timerDisplayEl = document.getElementById('timerDisplay');
    const energyDisplayEl = document.getElementById('energyDisplay');
    const doorHealthDisplayEl = document.getElementById('doorHealthDisplay');
    const lightHealthDisplayEl = document.getElementById('lightHealthDisplay');

    function initScene() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      // Room (inverted box)
      const roomGeometry = new THREE.BoxGeometry(ROOM_SIZE, ROOM_HEIGHT, ROOM_SIZE);
      const roomMaterial = new THREE.MeshStandardMaterial({
        color: 0x7a7a7a,
        roughness: 0.9,
        metalness: 0.0,
        side: THREE.BackSide,
      });
      roomMesh = new THREE.Mesh(roomGeometry, roomMaterial);
      roomMesh.position.y = ROOM_HEIGHT / 2;
      scene.add(roomMesh);

      // Door (one wall)
      const doorGeometry = new THREE.BoxGeometry(2, 4, 0.5);
      const doorMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
      doorMesh = new THREE.Mesh(doorGeometry, doorMaterial);
      doorMesh.position.set(0, 2, -ROOM_HALF_SIZE + 0.25);
      scene.add(doorMesh);
      interactableMeshes.push(doorMesh);

      // Light Generator (cylinder)
      const generatorGeometry = new THREE.CylinderGeometry(1, 1, 2, 16);
      const generatorMaterial = new THREE.MeshStandardMaterial({
        color: 0x00bcd4,
        emissive: 0x004f6b,
        emissiveIntensity: 0.6,
      });
      generatorMesh = new THREE.Mesh(generatorGeometry, generatorMaterial);
      generatorMesh.position.set(0, 1, ROOM_HALF_SIZE - 2);
      scene.add(generatorMesh);
      interactableMeshes.push(generatorMesh);

      const wallsMaterial = new THREE.MeshStandardMaterial({
        color: 0x444444,
        roughness: 0.9,
        metalness: 0.0,
      });

      const topWallWidth = ROOM_SIZE - CORRIDOR_WIDTH;
      const horizontalWallGeometry = new THREE.BoxGeometry(
        topWallWidth,
        ROOM_HEIGHT,
        WALL_THICKNESS
      );
      const leftGapEdgeX = -ROOM_HALF_SIZE + CORRIDOR_WIDTH;
      const rightEdgeX = ROOM_HALF_SIZE;
      const horizontalWall = new THREE.Mesh(horizontalWallGeometry, wallsMaterial);
      horizontalWall.position.set(
        (leftGapEdgeX + rightEdgeX) / 2,
        ROOM_HEIGHT / 2,
        1.5
      );
      scene.add(horizontalWall);
      wallMeshes.push(horizontalWall);

      // Lights
      ambientLight = new THREE.AmbientLight(0xffffff, 0.25);
      scene.add(ambientLight);

      pointLight = new THREE.PointLight(0xffffff, 1.2, 40);
      pointLight.position.set(generatorMesh.position.x, 4, generatorMesh.position.z);
      scene.add(pointLight);

      // Camera & renderer
      camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        100
      );
      camera.position.set(-2, PLAYER_HEIGHT, 3);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      // PointerLock controls
      controls = new PointerLockControls(camera, document.body);

      controls.addEventListener('lock', () => {
        isPaused = false;
        startOverlay.classList.add('hidden');
        pauseOverlay.classList.add('hidden');
      });

      controls.addEventListener('unlock', () => {
        if (gameOver) {
          return;
        }
        isPaused = true;
        if (gameStarted) {
          pauseOverlay.classList.remove('hidden');
        } else {
          startOverlay.classList.remove('hidden');
        }
      });

      window.addEventListener('resize', onWindowResize);

      document.addEventListener('keydown', onKeyDown);
      document.addEventListener('keyup', onKeyUp);
      document.addEventListener('mousedown', onMouseDown);
      document.addEventListener('mouseup', onMouseUp);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Milestone #2: Player Controller ----------------------------------------------------
    function onKeyDown(event) {
      keyStates[event.code] = true;
    }

    function onKeyUp(event) {
      keyStates[event.code] = false;
    }

    function onMouseDown(event) {
      if (event.button !== 0) return; // Left button only
      if (!controls.isLocked || gameOver) return;
      isRepairing = true;
    }

    function onMouseUp(event) {
      if (event.button !== 0) return;
      isRepairing = false;
    }

    function updatePlayer(delta) {
      const speed = 5; // units per second

      if (keyStates['KeyW']) controls.moveForward(speed * delta);
      if (keyStates['KeyS']) controls.moveForward(-speed * delta);
      if (keyStates['KeyA']) controls.moveRight(-speed * delta);
      if (keyStates['KeyD']) controls.moveRight(speed * delta);

      constrainPlayerPosition();
    }

    function constrainPlayerPosition() {
      const limit = ROOM_HALF_SIZE - 1;
      const pos = camera.position;

      pos.x = Math.max(-limit, Math.min(limit, pos.x));
      pos.z = Math.max(-limit, Math.min(limit, pos.z));
      pos.y = PLAYER_HEIGHT; // keep player grounded

      applyCollisions();
    }

    function applyCollisions() {
      const pos = camera.position;

      // Generator collision approximated as circle in XZ plane
      if (generatorMesh) {
        const generatorPos = generatorMesh.position;
        const dx = pos.x - generatorPos.x;
        const dz = pos.z - generatorPos.z;
        const distSq = dx * dx + dz * dz;
        const minDist = GENERATOR_COLLISION_RADIUS + PLAYER_RADIUS;

        if (distSq < minDist * minDist) {
          const dist = Math.sqrt(distSq) || 0.0001;
          const overlap = minDist - dist;
          pos.x += (dx / dist) * overlap;
          pos.z += (dz / dist) * overlap;
        }
      }

      if (doorMesh) {
        const halfDoorWidth = 1; // door width is 2
        const doorFrontZ = doorMesh.position.z + 0.25; // front face towards room
        const withinDoorWidth =
          pos.x > doorMesh.position.x - halfDoorWidth - PLAYER_RADIUS &&
          pos.x < doorMesh.position.x + halfDoorWidth + PLAYER_RADIUS;

        if (withinDoorWidth && pos.z < doorFrontZ + PLAYER_RADIUS) {
          pos.z = doorFrontZ + PLAYER_RADIUS;
        }
      }

      for (const wall of wallMeshes) {
        const geom = wall.geometry;
        if (!geom || !geom.parameters) continue;

        const halfWidth = geom.parameters.width / 2;
        const halfDepth = geom.parameters.depth / 2;
        const centerX = wall.position.x;
        const centerZ = wall.position.z;

        const dx = pos.x - centerX;
        const dz = pos.z - centerZ;

        const overlapX = halfWidth + PLAYER_RADIUS - Math.abs(dx);
        const overlapZ = halfDepth + PLAYER_RADIUS - Math.abs(dz);

        if (overlapX > 0 && overlapZ > 0) {
          if (overlapX < overlapZ) {
            pos.x += dx < 0 ? -overlapX : overlapX;
          } else {
            pos.z += dz < 0 ? -overlapZ : overlapZ;
          }
        }
      }
    }

    // Milestone #4: Interaction & Game Loop ---------------------------------------------
    function getFocusedInteractable() {
      const direction = new THREE.Vector3();
      camera.getWorldDirection(direction);
      raycaster.set(camera.position, direction);

      const intersects = raycaster.intersectObjects(interactableMeshes, false);
      if (intersects.length === 0) return null;

      const hit = intersects[0];
      if (hit.distance > INTERACT_DISTANCE) return null;

      if (hit.object === doorMesh) return 'door';
      if (hit.object === generatorMesh) return 'generator';
      return null;
    }

    function updateRepair(delta) {
      if (!isRepairing) {
        return;
      }

      const target = getFocusedInteractable();
      if (!target) {
        return;
      }

      if (energy <= 0) {
        isRepairing = false;
        return;
      }

      const energyCost = ENERGY_COST_PER_SEC * delta;
      const repairAmount = REPAIR_PER_SEC * delta;

      let repaired = false;

      if (target === 'door' && doorHealth < MAX_HEALTH) {
        doorHealth = Math.min(MAX_HEALTH, doorHealth + repairAmount);
        repaired = true;
      } else if (target === 'generator' && lightHealth < MAX_HEALTH) {
        lightHealth = Math.min(MAX_HEALTH, lightHealth + repairAmount);
        repaired = true;
      }

      if (repaired) {
        energy = Math.max(0, energy - energyCost);
        if (energy <= 0) {
          isRepairing = false;
        }
      }
    }

    function updateCycle(delta) {
      timer -= delta;

      if (timer <= 0) {
        if (cycleState === 'SAFE') {
          cycleState = 'DANGER';
          timer = DANGER_DURATION;
        } else {
          cycleState = 'SAFE';
          timer = SAFE_DURATION;
          // On start of SAFE cycle, refill energy
          energy = Math.min(MAX_ENERGY, energy + ENERGY_REGEN_SAFE);
        }
      }
    }

    function updateDecay(delta) {
      if (cycleState !== 'DANGER') return;

      const doorDecay = DOOR_DECAY_PER_SEC * delta;
      const lightDecay = LIGHT_DECAY_PER_SEC * delta;

      doorHealth = Math.max(0, doorHealth - doorDecay);
      lightHealth = Math.max(0, lightHealth - lightDecay);

      if (doorHealth <= 0 && !gameOver) {
        triggerGameOver();
      }
    }

    function updateVisuals() {
      // Door color from green (healthy) to red (broken)
      const t = THREE.MathUtils.clamp(doorHealth / MAX_HEALTH, 0, 1);
      doorMesh.material.color.copy(doorDamagedColor).lerp(doorHealthyColor, t);

      // Light intensity based on generator health
      const clampedLightHealth = THREE.MathUtils.clamp(lightHealth, 0, MAX_HEALTH);
      const lightHealthNormalized = clampedLightHealth / MAX_HEALTH;

      const pointIntensity = THREE.MathUtils.lerp(0.02, 1.8, lightHealthNormalized);
      pointLight.intensity = pointIntensity;

      const ambientIntensity = THREE.MathUtils.lerp(0.01, 0.25, lightHealthNormalized);
      ambientLight.intensity = ambientIntensity;

      if (generatorMesh.material && generatorMesh.material.emissive) {
        const emissiveStrength = THREE.MathUtils.lerp(0.05, 1.0, lightHealthNormalized);
        generatorMesh.material.emissiveIntensity = emissiveStrength;
      }
    }

    function updateUI() {
      if (cycleState === 'SAFE') {
        cycleStatusEl.textContent = 'SAFE CYCLE - SYSTEMS STABLE';
        cycleStatusEl.classList.remove('danger');
        cycleStatusEl.classList.add('safe');
      } else {
        cycleStatusEl.textContent = 'DANGER CYCLE - SURVIVE';
        cycleStatusEl.classList.remove('safe');
        cycleStatusEl.classList.add('danger');
      }

      timerDisplayEl.textContent = timer.toFixed(1) + 's';
      energyDisplayEl.textContent = 'Energy: ' + Math.round(energy) + ' / ' + MAX_ENERGY;
      doorHealthDisplayEl.textContent = 'Door: ' + Math.round(doorHealth) + '%';
      lightHealthDisplayEl.textContent = 'Generator: ' + Math.round(lightHealth) + '%';
    }

    function triggerGameOver() {
      gameOver = true;
      isRepairing = false;
      gameOverMessage.textContent = 'The door has failed. The outpost has been overrun.';
      gameOverOverlay.classList.remove('hidden');

      if (controls.isLocked) {
        controls.unlock();
      }
    }

    function restartGame() {
      cycleState = 'SAFE';
      timer = SAFE_DURATION;
      energy = MAX_ENERGY;
      doorHealth = MAX_HEALTH;
      lightHealth = MAX_HEALTH;
      isRepairing = false;
      gameOver = false;
      isPaused = true;

      camera.position.set(-2, PLAYER_HEIGHT, 3);

      gameOverOverlay.classList.add('hidden');
      pauseOverlay.classList.add('hidden');
      startOverlay.classList.remove('hidden');
      updateVisuals();
      updateUI();
    }

    function updateGame(delta) {
      updateCycle(delta);
      updateDecay(delta);
      updateRepair(delta);
      updateVisuals();
      updateUI();
    }

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      if (gameStarted && !gameOver && !isPaused) {
        updatePlayer(delta);
        updateGame(delta);
      }

      renderer.render(scene, camera);
    }

    // Simple configuration self-checks (lightweight tests)
    function runSelfTests() {
      console.groupCollapsed('Outpost Ecliptica - Self Tests');
      try {
        console.assert(SAFE_DURATION > 0 && DANGER_DURATION > 0, 'Cycle durations must be positive');
        console.assert(ENERGY_REGEN_SAFE > 0, 'Energy regeneration must be positive');
        console.assert(MAX_HEALTH === 100, 'Max health should be 100');
        console.assert(MAX_ENERGY === 100, 'Max energy should be 100');
        console.assert(pauseOverlay, 'Pause overlay should exist');
        const originalLightHealth = lightHealth;

        lightHealth = 0;
        updateVisuals();
        console.assert(pointLight.intensity <= 0.05, 'Point light should be almost off at 0% generator');
        console.assert(ambientLight.intensity <= 0.03, 'Ambient light should be almost off at 0% generator');

        lightHealth = MAX_HEALTH;
        updateVisuals();
        console.assert(pointLight.intensity >= 1.5, 'Point light should be strong at full generator health');
        console.assert(ambientLight.intensity >= 0.2, 'Ambient light should be strong at full generator health');

        lightHealth = originalLightHealth;
        updateVisuals();

        const originalCameraPos = camera.position.clone();

        camera.position.set(generatorMesh.position.x, PLAYER_HEIGHT, generatorMesh.position.z);
        constrainPlayerPosition();
        const dx = camera.position.x - generatorMesh.position.x;
        const dz = camera.position.z - generatorMesh.position.z;
        const distToGenerator = Math.sqrt(dx * dx + dz * dz);
        const minGeneratorDist = GENERATOR_COLLISION_RADIUS + PLAYER_RADIUS - 0.01;
        console.assert(
          distToGenerator >= minGeneratorDist,
          'Player collision with generator should prevent overlap'
        );

        if (wallMeshes.length > 0) {
          const testWall = wallMeshes[0];
          const geom = testWall.geometry;
          if (geom && geom.parameters) {
            const halfDepth = geom.parameters.depth / 2;
            const minWallDist = halfDepth + PLAYER_RADIUS - 0.01;
            camera.position.set(testWall.position.x, PLAYER_HEIGHT, testWall.position.z);
            constrainPlayerPosition();
            const distToWallCenterZ = Math.abs(camera.position.z - testWall.position.z);
            console.assert(
              distToWallCenterZ >= minWallDist,
              'Player collision with interior wall should prevent overlap'
            );
          }
        }

        camera.position.copy(originalCameraPos);

        console.log('Basic configuration and collision tests passed.');
      } catch (e) {
        console.error('Self tests encountered an error', e);
      }
      console.groupEnd();
    }

    // Bootstrapping ----------------------------------------------------------------
    initScene();
    updateVisuals();
    updateUI();
    runSelfTests();
    animate();

    startButton.addEventListener('click', () => {
      gameStarted = true;
      if (!gameOver) {
        controls.lock();
      }
    });

    restartButton.addEventListener('click', () => {
      restartGame();
    });

    resumeButton.addEventListener('click', () => {
      if (gameStarted && !gameOver) {
        controls.lock();
      }
    });

    document.addEventListener('keydown', (event) => {
      if (event.code === 'Escape') {
        if (controls.isLocked) {
          controls.unlock();
        }
      }
    });
  </script>
</body>
</html>
